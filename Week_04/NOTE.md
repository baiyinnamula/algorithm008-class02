## 学习笔记

### 广度优先搜索和深度优先搜索

#### 广度优先搜索

​	广度优先搜索，通俗的理解就是，地毯式层层推进，从起始顶点开始，依次往外遍历。广度优先搜索需要借助**队列来实现**，遍历得到的路径就是，起始顶点到终止顶点的最短路径。

#### 深度优先搜索

​	深度优先搜索用的是回溯思想，非常适合用递归实现。换种说法，深度优先搜索是借助**栈来实现**的。在执行效率方面，深度优先和广度优先搜索的时间复杂度都是 O(E)，空间复杂度是 O(V)。

### 贪心算法

​	贪心算法、分治算法、回溯算法、动态规划。更加确切地说，它们应该是**算法思想**，并不是具体的算法，常用来指导我们设计具体的算法和编码等。

##### 贪心算法解决问题的步骤：

​	**第一步，当我们看到这类问题的时候，首先要联想到贪心算法**：针对一组数据，我们定义了限制值和期望值，希望从中选出几个数据，在满足限制值的情况下，期望值最大。

​	**第二步，我们尝试看下这个问题是否可以用贪心算法解决**：每次选择当前情况下，在对限制值同等贡献量的情况下，对期望值贡献最大的数据。

​	**第三步，我们举几个例子看下贪心算法产生的结果是否是最优的：**大部分情况下，举几个例子验证一下就可以了。严格地证明贪心算法的正确性，是非常复杂的，需要涉及比较多的数学推理



### 二分查找

​	二分查找针对的是一个有序的数据集合，查找思想有点类似**分治思想**。每次都通过跟区间的中间元素对比，将待查找的区间缩小为之前的一半，直到找到要查找的元素，或者区间被缩小为 0。但是二分查找的代码实现比较容易写错。你需要着重掌握它的三个容易出错的地方：**循环退出条件、mid 的取值，low 和 high 的更新**。

​	二分查找虽然性能比较优秀，但应用场景也比较有限。底层必须依赖数组，并且还要求数据是有序的。对于较小规模的数据查找，我们直接使用顺序遍历就可以了，二分查找的优势并不明显。二分查找更适合处理静态数据，也就是没有频繁的数据插入、删除操作。



### 作业

使用二分查找，寻找一个半有序数组 [4, 5, 6, 7, 0, 1, 2] 中间无序的地方。

#### 解题思路

1. 因为原数组时个半有序数组，所以如果把数组从中间位置切成2个数组，则会得到一个有序子数组和一个半有序子数组。
2. 而且无序的位置一定会位于半有序的子数组里。
3. 这样一直找半有序的子数组，直到半有序数组只有2个元素，并且第一个元素大于第二元素，表明第二个元素就是原数组中间无序的地方。

#### 代码实现

```java
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

public class UnOrderPosition {

    @Test
    public void testUnOrderPosition() {
        int[] nums = new int[]{4, 5, 6, 7, 0, 1, 2};
        int position = unOrderPosition(nums);
        Assertions.assertEquals(4, position);
    }

    public int unOrderPosition(int[] nums) {
        int left = 0, right = nums.length - 1;
        while (left <= right) {
            if (left == right || (right - left == 1 && nums[left] >= nums[right])) {
                return right;
            }
            int mid = left + (right - left) / 2;
            //左半部分是有序数组
            if (nums[left] <= nums[mid]) {
                left = mid;
            } else {//右半部分是有序数组
                right = mid;
            }
        }
        return -1;
    }
}
```

时间复杂度：O(logn)，n 是原数组长度，由于使用的是二分查找，所以时间复杂度是对数级。

空间复杂度：O(1)，只使用了一个临时变量 mid ,空间复杂是常数级。



