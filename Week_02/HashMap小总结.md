##HashMap 小总结
1. HashMap 是基于 Hash Table 实现了 Map 接口。
2. HashMap允许 key 和 value 为 null。
3. 除了非同步（即线程不安全）和 允许 null  这两个特质以外跟 Hashtable 大致相同。
4. HashMap 不能保证 map 中元素的顺序。
5. 如果需要线程安全，需要Map m = Collections.synchronizedMap(new HashMap(...));来包装HashMap。
6. 有两个因素对 HashMap 对象的性能影响最大：分别是初始容量（initial capacity）和负载因子（load factor）。
7. 初始大小：HashMap 默认的初始大小是 16，当然这个默认值是可以设置的，如果事先知道大概的数据量有多大，可以通过修改默认初始大小，减少动态扩容的次数，这样会大大提高 HashMap 的性能。阿里《Java 开发手册》里也是推荐 HashMap 初始化时指定初始值大小。
8. 负载因子和动态扩容：最大负载因子默认是 0.75，当 HashMap 中元素个数超过 0.75*capacity（capacity 表示散列表的容量）的时候，就会启动扩容，每次扩容都会扩容为原来的两倍大小。
9. 散列冲突解决方法：HashMap 底层采用链表法来解决冲突。即使负载因子和散列函数设计得再合理，也免不了会出现拉链过长的情况，一旦出现拉链过长，则会严重影响 HashMap 的性能。于是，在 JDK1.8 版本中，为了对 HashMap 做进一步优化，引入了红黑树。而当链表长度太长（默认超过 8）时，链表就转换为红黑树。可以利用红黑树快速增删改查的特点，提高 HashMap 的性能。当红黑树结点个数少于 8 个的时候，又会将红黑树转化为链表。因为在数据量较小的情况下，红黑树要维护平衡，比起链表来，性能上的优势并不明显。
10. 散列函数：散列函数的设计并不复杂，追求的是简单高效、分布均匀。
